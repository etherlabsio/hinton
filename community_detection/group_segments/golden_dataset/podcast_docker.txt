{"body":{
        "contextId": "01DY2ZTPF4D7K51N898FCNHS77",
        "mindId": "01DAAQY88QZB19JQZ5PRJFR76Y",
        "instanceId": "5b2895ed-1eb7-45ea-9ec5-e0c7f315db01",
        "segments": [
            {
                "id": "0251eb25-697f-432f-be59-b7e0b6f12b27",
                "originalText": "Sure that the instances are distributed equally across the cluster the ports are published on all the nodes and the users can access the services using the IP of any of the notes and when they do the traffic is routed to the right Services internally. We've been talking about containers communicating with each other now, how exactly does that work. For example, in this case. I have a web service and a mySQL database service running on the same node or worker. How can it get my web service to access the database on the database container? One thing I could do is to use the internal IP address assigned to the MySQL container which in this case is 170 2.17 dot 0.3 but that is not very ideal because it is not guaranteed that the container will get the same IP when the system reboots. the right way to do it is to use the container name all containers in the docker host can resolve each other with the name of the container Docker has a built-in DNS server that helps the containers to resolve each other using the container name note that the built-in DNS server always runs at address 127 dot 0 dot 0 dot 11 That's all for now from this lecture on Advanced networking. I hope you had a good session and I will see you in the next lecture. ",
                "confidence": 0.896922734,
                "startTime": "2020-01-08T16:39:46Z",
                "endTime": "2020-01-08T16:41:23Z",
                "duration": 97,
                "recordingId": "1b9b81c3-90b8-4415-9a72-82ccfe4dfd20",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "3689b4dc-8acf-4785-86b4-5c5311e03224",
                "isEndOfSentence": true,
                "createdAt": "2020-01-08T16:41:24.659869234Z",
                "updatedAt": "2020-01-08T16:42:06.031514602Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "11073086-4088-41bf-b520-05df70c185ae",
                "originalText": "Take a look at the bridge Network in a bit more detail. For example, say we have multiple Docker host running containers. Each Docker host has its own internal private person Network in the 170 2.17 series allowing the containers running on each host to communicate with each other. However containers across the host has no way of communicating with each other unless you publish the ports on those containers and set up some kind. kind of routing yourself This is where overlay networks comes into play with Docker swarm. You could create a new network of type overlay which will create an internal private Network that spans across all the nodes participating in the swamp cluster. We could then attach the containers or services to this network using the network option while creating a service and so we can get them to communicate with each other. Either through the overlay Network. Let's talk about another type of network previously we learned about for publishing or Port mapping say we have a web service running on Port 5000 for an external user to access the web service. We must map the port to a port on the docker host in this case map Port 5000 on the container to Port 80 on the docker host in this case map Port 5000 on the docker host to Port 80. On the docker container. Once we do that a user will be able to access the web server using the URL with Port 80. Now this works just fine when running a single container and it's easy to understand. ",
                "confidence": 0.8527907916666666,
                "startTime": "2020-01-08T16:34:24Z",
                "endTime": "2020-01-08T16:36:14Z",
                "duration": 110,
                "recordingId": "f78acb1e-55a1-4780-a0ed-2b7ab468b086",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "3689b4dc-8acf-4785-86b4-5c5311e03224",
                "isEndOfSentence": true,
                "createdAt": "2020-01-08T16:36:15.121104797Z",
                "updatedAt": "2020-01-08T16:37:16.785153806Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "1c1a596f-646e-4a80-848f-6e83acde326a",
                "originalText": "What happens when we are working with a swamp cluster? For example, think of this host as a single node swamp cluster say we were to create a web server service with two replicas and a port mapping of Port 80 to 5,000 since this is a single node cluster both. The instances are deployed on the same node. This will result into web service containers both trying to map their 5000 ports to the And Port 80 on the docker host but we cannot have two mappings to the same port. This is where increase networking comes into picture when you create a Docker swamp, it automatically creates an inverse Network. The Ingress network has a built-in load balancer that redirects traffic from the published Port which in this case is Port 80 to all the map ports, which are the port's 5,000 in on each container. Since the Ingress network is created automatically. There is no configuration that you have to do you simply have to create the service you need by running the service create command and publish the port's you would like to publish using the dash P parameter just like before the Ingress Network and the internal load balancing will simply work out of the box, but it's important for us to know how it really works. ",
                "confidence": 0.8892855000000001,
                "startTime": "2020-01-08T16:36:14Z",
                "endTime": "2020-01-08T16:37:44Z",
                "duration": 90,
                "recordingId": "9dae3224-a10f-44e7-9a1c-97aa48c16820",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "3689b4dc-8acf-4785-86b4-5c5311e03224",
                "isEndOfSentence": true,
                "createdAt": "2020-01-08T16:37:45.181727633Z",
                "updatedAt": "2020-01-08T16:38:26.606532197Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "96eea739-65bd-41c5-abe9-fa89fb20997f",
                "originalText": "And welcome to this lecture on Docker networking. My name is Moon shot man and Beth and we are learning Advanced Docker Concepts. In this lecture, we will learn about Advanced networking Concepts such as Elena networks in Docker swarm embedded DNS servers routing mesh Etc. In the beginners course we discussed about three types of networks available in Docker Bridge null and host bridge is the default Network a container gets attached to if you would like to associate the container with any other network specify the network information using the network command line parameter like this. ",
                "confidence": 0.8726080433333333,
                "startTime": "2020-01-08T16:32:14Z",
                "endTime": "2020-01-08T16:32:57Z",
                "duration": 43,
                "recordingId": "c6fedc1c-a687-4669-8901-b6627db8e715",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "3689b4dc-8acf-4785-86b4-5c5311e03224",
                "isEndOfSentence": true,
                "createdAt": "2020-01-08T16:32:57.428641332Z",
                "updatedAt": "2020-01-08T16:33:18.801157126Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "a269da35-5a75-4c5b-8ddf-bc5bcd4d8048",
                "originalText": "Network is a private internal Network created by Docker on the host all containers attached to this network by default and they get an internal IP address usually in the range 170 2.17 series The containers can access each other using this internal IP. If required to access any of these containers from the outside world map Port of these containers to port on the docker host as we have seen. before Another type of network is the host Network this takes out any network isolation between the docker host and the docker containers meaning if you were to run a web server on Port 5000 in a web app container. Attach the host Network. It is automatically accessible on the same port externally without requiring to publish the port using the dash P option as web container uses the host Network this will Would also mean that unlike before you will now not be able to run multiple web containers on the same host on the same port as the ports are now common to all containers in the host Network. The third option is the non-network the containers are not attached to any network and doesn't have any access to the external network or other containers. ",
                "confidence": 0.822066925,
                "startTime": "2020-01-08T16:32:57Z",
                "endTime": "2020-01-08T16:34:23Z",
                "duration": 86,
                "recordingId": "8fc512de-cd28-4333-ab9e-ebb42afba67a",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "3689b4dc-8acf-4785-86b4-5c5311e03224",
                "isEndOfSentence": true,
                "createdAt": "2020-01-08T16:34:24.624935415Z",
                "updatedAt": "2020-01-08T16:35:07.332544682Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "e9023ffd-7541-44a4-b379-edbe9d837ce5",
                "originalText": "Now look at how it works when there are multiple nodes in the docker swamp cluster. In this case. We have a three node Docker swamp cluster running two instances of web server since we only requested for two replicas. The third Docker host is free and has no instances. Let's first keep Ingress networking out of our discussion for a minute and see how this might work without the Ingress networking. First of all, how do we expect? Checked the user to access our services in a swamp cluster of multiple nodes since this is a cluster. We expect the users to be able to access services from any node in our cluster. Meaning any user should be able to access the web server using the IP address of any of these containers since they are all part of the same cluster without Ingress networking a user could access the web server on nodes 1 & 2 but not Note 3 because there is no web service instance running on node 3 Let's now bring back Ingress networking Ingress networking is in fact a type of overlay Network meaning. It's a single Network that spans across all the nodes in the cluster. The way the load balancer works is it receives requests from any node in the cluster and forwards that request to the respective instances on any other node essentially creating a routing mesh the routing mesh helps in routing the user. Traffic that is received on a node that isn't even running an instance of the web service to other nodes where the instances are actually running. And again, all of this is the default behavior of Docker swamp and you don't need to do any additional configurations. Simply Create Your Service specify the number of replicas and publish the port Docker swamp. ",
                "confidence": 0.8300075719999999,
                "startTime": "2020-01-08T16:37:46Z",
                "endTime": "2020-01-08T16:39:46Z",
                "duration": 120,
                "recordingId": "d6d4ebc4-199f-471a-b912-8a551d70f981",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "3689b4dc-8acf-4785-86b4-5c5311e03224",
                "isEndOfSentence": true,
                "createdAt": "2020-01-08T16:39:47.593102785Z",
                "updatedAt": "2020-01-08T16:40:49.14379895Z",
                "deletedAt": null,
                "deleted": false
            }
        ]
    }}
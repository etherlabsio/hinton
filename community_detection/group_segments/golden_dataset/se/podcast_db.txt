{"body": {
        "contextId": "01DY2ZTPF4D7K51N898FCNHS77",
        "mindId": "01DAAQY88QZB19JQZ5PRJFR76Y",
        "instanceId": "75d72774-a0d5-4374-ab09-524e628bf5a3",
        "segments": [
            {
                "id": "0028fbf8-cb03-4e10-9863-1ddab5c69f20",
                "originalText": "Fields so you might have a different structure in there. There is no scheme implied on you so you could have this documented a collection. But then also this one where you got no age or this one where you got no name and it's not just that you say the value is null you can really have totally different documents in one of the same collection. There's of course has to downside of you not being sure if all the data adheres to your format, but on the other hand, you don't want to have that form in the first place if you decide for such a solution because the big advantage of course is that this is a super flexible solution here. You can add new data. Let's say you're building a new business you're building a new app and at some point you want to fetch more user data than you did in the past not crucial one, which would well kind of be bad for the existing users but maybe useful data which you want to have for all new users. Now you can still store them all in the same collection because there is no scheme. My implied and you can therefore be flexible regard regarding your data format. There also are no relations. Well, at least kind of you can theoretically set up relations and do the querying manually, but in general there are no relations in a nosql world. You have your collections with your documents in there and whilst you can as I just said kind of relate multiple Collections and that is possible and it is done in reality. Nosql Solutions nosql databases like mongodb rely weigh less on that relations instead the ideas that you put all the information in one place. So you might have your orders collection where each order does not only contain the user and product ID, but it contains the key user data you need to work with the order something like the addressed email and the ID and the key product data you need like the price the name and the ID anything like that? ",
                "confidence": 0.7974033375,
                "startTime": "2020-01-08T16:45:16Z",
                "endTime": "2020-01-08T16:47:16Z",
                "duration": 120,
                "recordingId": "2576029f-c1b7-473c-b2a5-70dfcad448b9",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "4515d645-8698-4ff4-8312-29a81dca5d73",
                "isEndOfSentence": true,
                "createdAt": "2020-01-08T16:47:17.393044777Z",
                "updatedAt": "2020-01-08T16:47:58.81727273Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "04149225-3367-4cfd-96dd-7260f2c06072",
                "originalText": "Bull which belongs to that user and then would be one to one because one user has one contact data entry or record and one contact data record belongs to one user. You could also add a user ID field to the contact data table and point at the user to which it belongs. We can all have one too many and strictly speaking. Our one-to-one here would be one too many because since we don't assign a user ID to each contact data the radically one contact data. That could belong to multiple users. Here's another example. Once you many would be pretty much the same now with users and products. We have a Creator ID on the product pointing at the user who created that product and they are for this product only belongs to this one user. But when user can be part of multiple products and then we of course we got many to many many to many is the case. We already saw we got two tables users and roles. Let's say a role could be something like Admin editor stuff like that and we want to connect these two tables. Now since a user can have multiple roles and a role can be assigned to multiple users. There is no way we store that information into tables only because we would have to add one new field. So one new column for every roll you want to assign to the user and the other way around and since we can't predict how many roles are user will have and how many users are role will be assigned to you we Add an extra table in between user roles table. This table has a user ID and a roll ID field and therefore it creates as many connections as we need. That's a many-to-many relationship. So you can we learn way more about that and further links can be found in the video description, but this is not about learning all about SQL. It's about learning the key characteristics and that's the strong schema and the relational nature of the data. We store data distributed across multiple. ",
                "confidence": 0.785099655,
                "startTime": "2020-01-08T16:41:16Z",
                "endTime": "2020-01-08T16:43:16Z",
                "duration": 120,
                "recordingId": "04e68c4d-da0c-47a7-813b-c9c6d85dce7b",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "4515d645-8698-4ff4-8312-29a81dca5d73",
                "isEndOfSentence": true,
                "createdAt": "2020-01-08T16:43:17.575071044Z",
                "updatedAt": "2020-01-08T16:43:59.327120588Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "08edcfee-9d16-476a-8db4-fa90277e5039",
                "originalText": "You might need to display it on an order page and process it internally you would put that into your collection. And therefore you might still have an extra users collection and extra products collection with more detailed data, but you don't really need to query that connect data because you got the data you need in each collection, which you might be querying from different points of your application. And this is the idea have less relation merging going on have super. Both fast and efficient queries day of work, but of course the disadvantage is that you have some duplicate data If the product name changes, you have to update it not only in the products collection, but Alton the orders collection, but if you have an application where you have a lot of reads and not that many rights for products, for example, then this would be a great setup still. So who is the winner then the more strict sequel world or the more loose nosql world the most Important thing first there is no clear winner. It really depends on the kind of application or building and the kind of data you're storing and in really big applications where businesses you typically use both Solutions because you work with different data or with different applications. And therefore you have different needs each solution has its strengths SQL for example uses schemas and that can be both an advantage or disadvantage. It's a disadvantage if you want to be Flexible about the data but it's an advantage. If you want to have the predictable layout the relations also can be a huge Advantage. If you have data like say products and users and they are changed frequently, then it might be worse to update them in multiple collections in the nosql world. If you can go for the more structured SQL approach where you only update the user in your users table and every new query which creates or ",
                "confidence": 0.88912937,
                "startTime": "2020-01-08T16:47:16Z",
                "endTime": "2020-01-08T16:49:16Z",
                "duration": 120,
                "recordingId": "e586caca-d278-4c15-8e4e-9a5b566203d0",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "4515d645-8698-4ff4-8312-29a81dca5d73",
                "isEndOfSentence": false,
                "createdAt": "2020-01-08T16:49:17.358076503Z",
                "updatedAt": "2020-01-08T16:50:19.339106088Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "2bba77d5-41ed-4bfa-96a5-d100e2e9db53",
                "originalText": "With SQL we will have very strict requirements for the data. We store in our database tables to be precise with a clear schema of which data can go into a table and this schema is defined by so-called Fields. So in our products table we would have for example these fields and ID a name a price and a description and every new entry we add every new record. As it is called every new row in our table is well a record that has values for these fields and the important thing is it can't have more Fields than the ones we defined for the table. So it's not possible. That one record has like a name a price in the description and the next record also has named price description and some extra data like tags you can add this by adding a tags field, but then all the entries were all Records need to have tags. They might be null. They might be empty but you need to provide some information for that text field and if it only is that there is no information. So you have a clear schema and this is how a database table looks like in a sequel world. Now, this is a database table and that schema thing is really important all records in a table have to adhere to this schema and when we put data into such a table, we therefore have to to normalize it which means we have to ensure that however, we are fetching the data and whichever extra data we might have or whichever data might be missing that we bring it into a format which fits into that table. That's one important building block of a sequel world. The average important building block is that you typically don't only work with one table but instead with multiple tables which are related so we could have a user's a products in the orders table. We would not ",
                "confidence": 0.8648265625,
                "startTime": "2020-01-08T16:37:16Z",
                "endTime": "2020-01-08T16:39:16Z",
                "duration": 120,
                "recordingId": "0770d33e-45a1-46eb-a0a5-3b3677725c53",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "4515d645-8698-4ff4-8312-29a81dca5d73",
                "isEndOfSentence": false,
                "createdAt": "2020-01-08T16:39:17.501556459Z",
                "updatedAt": "2020-01-08T16:39:58.920200107Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "3c8a1e36-9505-432d-b77e-57a032c785fd",
                "originalText": "Welcome to this video SQL or nosql. That is a question. You get a lot or often. The question is my SQL or mongodb. Either way. Let's have a look at when you might want to choose which database and what the difference is actually are. ",
                "confidence": 0.86358666,
                "startTime": "2020-01-08T16:34:56Z",
                "endTime": "2020-01-08T16:35:14Z",
                "duration": 18,
                "recordingId": "9b5058c7-8347-4484-9d4c-ddf082348acc",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "4515d645-8698-4ff4-8312-29a81dca5d73",
                "isEndOfSentence": true,
                "createdAt": "2020-01-08T16:35:14.395299478Z",
                "updatedAt": "2020-01-08T16:35:35.354646553Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "66caad15-0de5-445e-8c9a-d18b73e757a9",
                "originalText": "Have one orders table only which then holds all the products and users information per record instead. We would split it up. We would have a user's table with its fields and then we have some entries in there and the same for the products. So we would have something like this where we manage users and product separated from each other. But of course there is a connection for example a product could be created by a user or in this example here we could have orders. Order simply is a combination of a product and a user because when user might have many orders and one product might always be part of different orders of different users. So the orders table would be our connection here. It would be setting up the relations. We would have a user ID in a product ID field in there. And therefore we can connect a specific user to a specific product the product which was ordered by the user. This is very typical for the sequel world and Data, relational databases which use SQL and therefore we got two important characteristics already the strict schema and dead relation World, by the way, there are multiple types of relations in SQL world. We just saw the many-to-many relationship. Obviously, we always got a one-to-one relation. Now, here's an example we could have a user and we could have a table with contact data. The user may be is made up of ID and name age and the contact data could be also an ID. Typically every record has an ID in every table but besides the idea contact data Field contact data record could have the email and phone number fields. And then maybe we want to separate it into two tables. Are we still want to ensure that every user has one contact data piece and that can be done by adding a contact data ID field to the user which holds the ID off the contact data in the contact data. ",
                "confidence": 0.8550787625,
                "startTime": "2020-01-08T16:39:16Z",
                "endTime": "2020-01-08T16:41:16Z",
                "duration": 120,
                "recordingId": "9f76c9fa-c10e-4fed-a4f1-0ec0eac2f214",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "4515d645-8698-4ff4-8312-29a81dca5d73",
                "isEndOfSentence": true,
                "createdAt": "2020-01-08T16:41:17.285148542Z",
                "updatedAt": "2020-01-08T16:41:58.856483118Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "6fb04a6c-5936-4278-9370-1880329cfae6",
                "originalText": "Pulls in that user information will automatically take that updated user because it's only stored and managed one place opposed to multiple places. The downside is that if you have these complex queries and you do a lot of reads that might be worse performance or might be leading to worse performance than in the nosql world where you will have all the data already merged in the right way in one collection and you don't need to merge it manually through a query data. 'he is also distributed across multiple tables in the sequel World therefore and this can all be both an advantage or disadvantage for the reasons. I just mentioned regarding the updating. We all have to talk about scaling and we can differentiate between horizontal scaling and vertical scaling. Now. What's the difference now in both cases? Let's say we have our database server if we scale horizontally, we simply add more servers. We add more power by adding more service. Obviously we have to ensure that our database is split up across these servers, but we still can work with it. And that is harder than you might guess and for SQL service. It's especially hard and often not possible because the data can't be split across multiple servers. So therefore this horizontal scaling is often very often not supported for SQL databases vertical scaling Dentistry alternative there. You simply add more. More power to your existing server, the downside of that of course is that there will be some limit. There's only that much computing power you can add into a computer and thereafter it will be hard and that is indeed one of the restrictions of a SQL database Approach at some point scaling can become super hard because horizontal scaling is impossible or very hard and vertical scaling has limits now chances are that you might not hit that for your ",
                "confidence": 0.855625805,
                "startTime": "2020-01-08T16:49:16Z",
                "endTime": "2020-01-08T16:51:16Z",
                "duration": 120,
                "recordingId": "5d6c14c3-df9e-491b-b9a0-cb1c6be72fe8",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "4515d645-8698-4ff4-8312-29a81dca5d73",
                "isEndOfSentence": false,
                "createdAt": "2020-01-08T16:51:17.603592266Z",
                "updatedAt": "2020-01-08T16:51:58.998973414Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "7f2bca33-3c16-4e9c-89c1-d323ba580c11",
                "originalText": "Let's dive into that and to understand whether you want to choose a sequel or a nosql data for your next web project or whatever. Your next project is. You have to understand how both database systems work what separates these worlds. So let's start with SQL now SQL is not in the database SQL stands for structured query language and in the end SQL is a language that allows you to write database queries that look something like this. No, there are more commands to just deselect command. Umm, and but this is how you create such queries you have certain key words certain syntax features, like select keyword or the from keyword and you add your own data like select which fields from which table in this example here so that you can retrieve the data from the database you need and there are not just commands for retrieving data. There are all the commands for inserting updating or deleting data for creating you tables for Dining tables if your data is distributed across multiple tables. So there are a bunch of commands which you can combine. It's quite powerful. This is a sequel now often when we think about SQL words is no sequel we of course think about the databases that are behind that so the database we will get the data from with the SQL language here or with the structured query language the database we typically use is a relational database that means we have a database which works with certain assumptions or in a certain way and it supports the SQL language D structured query language such a database works with tables something like a products table. For example, we want to store product of our app we could do that in a products table. So a table is like a database in a storage container now in SQL world where we queried ",
                "confidence": 0.7993437275,
                "startTime": "2020-01-08T16:35:16Z",
                "endTime": "2020-01-08T16:37:16Z",
                "duration": 120,
                "recordingId": "3ee20261-4a81-4dae-9433-8fc7c86fd00d",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "4515d645-8698-4ff4-8312-29a81dca5d73",
                "isEndOfSentence": false,
                "createdAt": "2020-01-08T16:37:17.248212736Z",
                "updatedAt": "2020-01-08T16:38:19.29427409Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "8a730a1c-f88d-43a4-bc1d-74ffa30ce8f7",
                "originalText": "To display orders and that is what I mean here. You have some Collections and the amount of course varies depending on your application size. You have some collections which typically serve certain purposes and the idea is not to have thousands of tables which you connect with relations, but instead to shrink that a bit and instead have all the data in one collection that you typically need in one part of your application. Now I already did talk about the scaling nosql can be scaled. Held in both directions, which is great, of course and finally it offers a great performance for Mass read and writes except for the cases where we well update a lot of collections regularly. So if we have that user in four different Collections, and that user data changes all the time having to update this all the time. And again we're talking about thousands of write requests per second here can be leading towards performance than in the sequel world. Now that was a lot of talking and finally the question remains which approach to you want to choose generally you can build every application with either approach. There is no clear border where you would say this has to use a SQL database or Des has to use a nosql database. You can build any application with either database system and you'll probably only face issues. If you become really really big at this point though as I already mentioned you typically use Use both systems both approaches for different data types in your business. So in the end you have to think about the core strength. Do you want to have a clear schema? Do you use a lot of relations? Do you maybe work with data that changes frequently and is used on different parts of your application a lot. Maybe you need a SQL database for that because this would allow you to manage your data exactly. ",
                "confidence": 0.868159455,
                "startTime": "2020-01-08T16:53:16Z",
                "endTime": "2020-01-08T16:55:16Z",
                "duration": 120,
                "recordingId": "b92e2d5f-d85d-4a03-9c71-18e91207a0e5",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "4515d645-8698-4ff4-8312-29a81dca5d73",
                "isEndOfSentence": true,
                "createdAt": "2020-01-08T16:55:17.370341252Z",
                "updatedAt": "2020-01-08T16:55:58.822204412Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "b8791c5d-33c3-4116-ab9a-d08748f7e36d",
                "originalText": "Will's which we then connect through relations and the SQL language to structured query language is capable of querying these relations. There are special commands so-called joins, which you can use to retrieve connect the data in one result set. Even if it is stored in multiple tables, obviously, the more complex the relation is and the more tables are included the longer such an operation can take but it is possible and it is one of the core Has strengths of the sequel world the fact that you have normalized distributed data, which can merge together with SQL queries. Now that was the sequel world. Let's now have a look at the mongodb world or the nosql world. There are other nosql solutions to AWS dynamodb would be one for example a serval as one now. I'll have a look at mongodb since it's the most popular nosql database now. What is a nosql database or What is mongodb now the name mongodb simply stemming from the word humongous because it's built to store lots and lots of data in a very efficient way something sequel Solutions can struggle with but more on that later. So how does it work? Well, we have databases in the nosql world to like a shop database. But then in there we don't have tables but so-called collections, but you could translate it with table essentially lay maybe the you Users in orders collection in our shop database now in such a collection. We have so-called documents documents. Now look at the different they are basically the rows in your table you could say but not only do they look a bit like Jason here. The really interesting thing is that they don't have to use the same schema. You can have multiple documents in one collection, which have different ",
                "confidence": 0.8449631750000001,
                "startTime": "2020-01-08T16:43:16Z",
                "endTime": "2020-01-08T16:45:16Z",
                "duration": 120,
                "recordingId": "4365c78f-f0a1-4fb0-ae9a-edd8f5176fe2",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "4515d645-8698-4ff4-8312-29a81dca5d73",
                "isEndOfSentence": false,
                "createdAt": "2020-01-08T16:45:17.518073386Z",
                "updatedAt": "2020-01-08T16:46:19.023029105Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "d28844f3-1373-4c1e-aa55-f152d3530ebf",
                "originalText": "That way the nosql approach is great for applications where you want to read a lot maybe also write a lot but not necessarily update dozens of places in your database in each right instead. Maybe you got a few features in your application which are used heavily and if you ever features which are not used that much and then you want to ensure that you can read all the data you want to display as quick as possible. Oil and that you don't have to run complex showing queries for that may be scaling all the matters a lot then and therefore the horizontal scaling is a great strength. So then you might be leaning towards the nosql solution. I'd say that no sequel is a bit more hyped these days and it offers significant advantages, but it's wrong to say that it's strictly better than sequel approaches and the other way around too in the end. It is always coming down to testing playing around. And and simply choosing the right tool for the job you want to get done? ",
                "confidence": 0.8158760766666666,
                "startTime": "2020-01-08T16:55:16Z",
                "endTime": "2020-01-08T16:56:23Z",
                "duration": 67,
                "recordingId": "f51262f7-7bc6-4c55-98c9-771e132803d2",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "4515d645-8698-4ff4-8312-29a81dca5d73",
                "isEndOfSentence": true,
                "createdAt": "2020-01-08T16:56:23.919931884Z",
                "updatedAt": "2020-01-08T16:57:05.247103888Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "db77cdab-e65d-4d84-a18b-6669aadf1463",
                "originalText": "Because we're talking about a lot of computing power will we Face the limit but it is something to keep in mind and nosql is better there because mongodb and other nosql approaches can easily be split horizontally due to the way the data is stored that is way simpler because you have no relations you have these Standalone Collections. And even in one collection, you can split that data across multiple servers and then merge it together automatically. So horizontal scaling is possible. Nosql, it's not in SQL when everything we have to consider is that for SQL we have certain limitations if we have lots of and with that I mean tens of thousands per second read and write requests, especially if we have very complex queries with a lot of joins now, no sequel is schema-less and that can be an advantage since you're more flexible. Of course, it can be a disadvantage because you can't rely on your record to have a certain field. Might just not have it because there is no schema to force it to have it you all have no relations or very few relations. And this is great for reading a lot. It can be a disadvantage. If you have a lot of right requests that affect multiple collections because then you have to update some data in multiple collections because you're duplicating it instead of keeping a relation. So if you have data, which is strongly related and which you store in multiple Collections and you update that data. A lot nosql might not be your best solution now data is typically merged or nested in a few Collections. And with that. I don't mean that you don't have many collections. I really just want to emphasize that you typically want to keep all the data in a collection that you query a lot. If you got our orders page you want to put all the data in that orders collection, which you need on the orders page. So did you don't have to reach out to the products collection just ",
                "confidence": 0.8602189825000001,
                "startTime": "2020-01-08T16:51:16Z",
                "endTime": "2020-01-08T16:53:16Z",
                "duration": 120,
                "recordingId": "e1de63be-0a8c-4449-8bf4-f7c6db3b8c31",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "4515d645-8698-4ff4-8312-29a81dca5d73",
                "isEndOfSentence": false,
                "createdAt": "2020-01-08T16:53:17.393984391Z",
                "updatedAt": "2020-01-08T16:53:58.852273932Z",
                "deletedAt": null,
                "deleted": false
            }
        ]
    }}
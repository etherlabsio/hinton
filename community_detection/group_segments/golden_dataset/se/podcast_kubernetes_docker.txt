{"body":{
        "contextId": "01DBB3SN6EVW6Y4CZ6ETFC9Y9X",
        "mindId": "01DAAYHEKY5F4E02QVRJPTFTXV",
        "instanceId": "988c0172-759a-4f2d-b863-edbec983e796",
        "segments": [
            {
                "id": "15e4d3fe-2176-4a38-9d52-6245995bb71a",
                "originalText": "Add the OS which is generally going to be Ubuntu when you're working with docker. And we'll have the docker demon installed on top of that OS that's what allows us to spin up containers. So Docker actually provides us a number of great tools for working with our containerized applications. So once we take these applications create need doc containers out of them will do Docker build Docker push up to a registry and then SSH into our stack and do Docker run commands or even use Docker compose to spin up our containers. So let's take a look at what that would look like. So we've got rjs application. We've got our Java app as well as the python application. ",
                "confidence": 0.8231664233333333,
                "startTime": "2020-02-03T12:42:13Z",
                "endTime": "2020-02-03T12:42:57Z",
                "duration": 44,
                "recordingId": "c811128e-a9c2-4b8f-a4ee-6e9d2bbabb65",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "b6a2653d-fcee-4750-ae20-93e078f3ef6e",
                "isEndOfSentence": true,
                "createdAt": "2020-02-03T12:42:58.305208994Z",
                "updatedAt": "2020-02-03T12:43:19.420559511Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "1b5d54d1-f52c-4b29-9fe2-6ae8fdffd7c5",
                "originalText": "And let's go ahead and scale out these individual pieces as well. So take advantage of all the resources we have. ",
                "confidence": 0.89820015,
                "startTime": "2020-02-03T12:42:57Z",
                "endTime": "2020-02-03T12:43:05Z",
                "duration": 8,
                "recordingId": "8475cc08-b1a8-4e62-9ba5-22a4d4125b27",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "b6a2653d-fcee-4750-ae20-93e078f3ef6e",
                "isEndOfSentence": true,
                "createdAt": "2020-02-03T12:43:05.591033556Z",
                "updatedAt": "2020-02-03T12:43:26.58021458Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "3c0ed251-e2d3-4275-81f1-06248a91084b",
                "originalText": "Backed by no Jess will say that this database access application a fan of using Java for database access. So we'll say Java up here and for accessing external apis, maybe we use Python maybe a flask application that allows us to serve rest endpoints now putting on my hat as a Docker Ops engineer using a purely Docker approach to deploying an application. Let's take this app and move over to a a sample server stack that we have sketched out over here on every server stack. You're going to have the basics right? So we'll have the hardware. ",
                "confidence": 0.858697885,
                "startTime": "2020-02-03T12:41:33Z",
                "endTime": "2020-02-03T12:42:12Z",
                "duration": 39,
                "recordingId": "1d7c4f59-d950-42d4-b2af-47d7a8e1c651",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "b6a2653d-fcee-4750-ae20-93e078f3ef6e",
                "isEndOfSentence": true,
                "createdAt": "2020-02-03T12:42:13.136306559Z",
                "updatedAt": "2020-02-03T12:42:34.465030066Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "5fb06375-99f2-43b3-9be6-5719b95923cc",
                "originalText": "Kubernetes deployment is not a one-time thing, but it's something that grows and lives and breathes with the application and our and our full stack. So for example, if the react app happens to crash kubernetes will automatically be started to get back to that state that we've identified when we first created that deployment so deployment is always growing and always living with our application. So I think we can effectively say that it's made deployment addition to scaling easier. Let's talk about development. You might be wondering so once we've created like the deployments for each of these Individual Services and scaled all of them out. We have a lots of different micro Services out there with different endpoints. So for example, if our front end needs to access the database there might be maybe eight different versions of that Java app that that talk to that database. We have to talk to one of them. To get our kind of request fulfilled, right? So what kubernetes does is deploys load balances for all of our micro services that we scaled out. And in addition takes it takes advantage of service registry and Discovery capabilities to allow our applications to talk to each other using something called a kubernetes service. So for each of these kubernetes will also create a service which we can simply label service a B and see obviously you can have more meaningful names for those as well. But very simply these applications can now speak to each other just by using those service names that are laid out in kubernetes. So essentially I can say that kubernetes is made development easier. And the last thing I want to touch on is monitoring kubernetes has a lot of built-in capabilities to allow you to kind of see logs see CPU load all in there need UI, but the fact is there's some time. It's more that you want to see which our application and the open source Community out. There has developed a number of amazing tools to give you introspection into your ",
                "confidence": 0.8259797166666667,
                "startTime": "2020-02-03T12:45:51Z",
                "endTime": "2020-02-03T12:47:51Z",
                "duration": 120,
                "recordingId": "c0cd79d7-fba6-4097-a2d3-c7c98c9ea808",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "b6a2653d-fcee-4750-ae20-93e078f3ef6e",
                "isEndOfSentence": false,
                "createdAt": "2020-02-03T12:47:52.916843093Z",
                "updatedAt": "2020-02-03T12:48:34.332676453Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "cf9e079e-34b1-4d63-ae36-0897444b1484",
                "originalText": "Updates that kind of thing I'd say there's three major advantages that kubernetes provides that I want to walk through deployment making development easier and providing monitoring tools. The first step as expected is going to be deployment. So coming back to our application architecture. Let's say we want to deploy that react app about eight times. So we'll say we want eight instances each of them. Let's say we expected to consume about 128 megabytes and then we can actually specify some other parameters in there. As well policies like went to restart that kind of thing. And when we box that up what we get is a kubernetes deployment. ",
                "confidence": 0.8961146799999999,
                "startTime": "2020-02-03T12:45:05Z",
                "endTime": "2020-02-03T12:45:48Z",
                "duration": 43,
                "recordingId": "bafb4134-1dfa-4a58-8d32-2ebbf9ffc79d",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "b6a2653d-fcee-4750-ae20-93e078f3ef6e",
                "isEndOfSentence": true,
                "createdAt": "2020-02-03T12:45:49.376422526Z",
                "updatedAt": "2020-02-03T12:46:10.556415726Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "e44571d0-e321-4c75-8820-dfe9a4017308",
                "originalText": "Hi everyone. My name is Savannah and I'm a developer Advocate with IBM here at IBM were always enabling developers to be able to use the latest and greatest Technologies When developing their applications, but a question I almost always seem to be running into is whether or not you should use Docker versus kubernetes. I think there's this misconception out there that you have to be using one or the other but the fact is kubernetes allows you to use your existing Docker containers and workloads, but allows you to tackle some of the complexity issue into when moving to scale to better answer this question. Let's start with a simple Cloud native application sketched out up here and let's just say that the front end of this application is something that we wrote with react. ",
                "confidence": 0.8935566500000001,
                "startTime": "2020-02-03T12:40:40Z",
                "endTime": "2020-02-03T12:41:32Z",
                "duration": 52,
                "recordingId": "8a927aab-359b-4e63-99a9-699cf714ebe8",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "b6a2653d-fcee-4750-ae20-93e078f3ef6e",
                "isEndOfSentence": true,
                "createdAt": "2020-02-03T12:41:33.139367893Z",
                "updatedAt": "2020-02-03T12:41:54.309441249Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "f095c281-7573-4f1d-9d3e-23c55ab19b1a",
                "originalText": "kill them out and we can do this as many times as we want but let's assume that we scale them out twice for now to make effective use of all the resources that we have available. So using darker and the tools the doctor makes available a simple deployment is very easy, but let's imagine that our application starts to get a lot more load a lot more people are hitting it and we realize hey we need to scale out to be able to provide a better user experience. So as an option generator my first instinct might be hey, I've already got scripts to make this stack. Let's just Simply create new good new hardware and do that exact same deployment multiple times. This can fall apart for many reasons. When you start moving to scale. For example, what if your Dev team has to create a new micro service to support a new requirement. Where do we be peace those in especially if you already have effective use of the hardware options during would have to find that out and in addition a big advantage of micro service based applications is being able to scale out individual components in Visually, so that's another thing that the Ops engineer would have to write scripts for and find the most effective way to scale things out in response to load to identify and address user experience issues when moving to scale so this is where an orchestration tool comes in something like kubernetes which is going to allow you to use your existing Docker eyes applications, but orchestrate them and do make it more effective use of your servers in space. So we have sketched out down here is a number of boxes. Which represent a server stack but in the kubernetes land we call them worker nodes. So we're going to have kubernetes installed on every single one of these worker nodes and the main one is going to be the master node. Whereas the other ones are workers. This master node is actually connected to all the worker nodes and decides where to host. Our applications are Docker containers how to piece them together and even manages orchestrating them starting stop. ",
                "confidence": 0.85478778,
                "startTime": "2020-02-03T12:43:05Z",
                "endTime": "2020-02-03T12:45:05Z",
                "duration": 120,
                "recordingId": "efa34b91-907e-42d3-a546-661965902cea",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "b6a2653d-fcee-4750-ae20-93e078f3ef6e",
                "isEndOfSentence": true,
                "createdAt": "2020-02-03T12:45:06.960562897Z",
                "updatedAt": "2020-02-03T12:45:48.676962416Z",
                "deletedAt": null,
                "deleted": false
            }
        ]
    }}
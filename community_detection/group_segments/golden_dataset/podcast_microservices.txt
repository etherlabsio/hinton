{"body":{
        "contextId": "01DY2ZTPF4D7K51N898FCNHS77",
        "mindId": "01DAAQY88QZB19JQZ5PRJFR76Y",
        "instanceId": "37e6d636-de98-479a-b933-47b6e7cfd48c",
        "segments": [
            {
                "id": "05992bdd-d8fa-4955-86f1-bb507e9e7ce2",
                "originalText": "A lot of Buzz about microservices these days. Everybody wants to create applications using the micro service architecture in this video. Let's look at what microservices are really all about. But rather than reading out a list of architectural Concepts, we will approach that a completely different place by me telling you a story that you really need to know. Let's go back in time to the old days when we didn't have anything called micro services. In fact, we'll go so far back. They'll go to a time when a computer was big enough to fill the room. Mr. Seen pictures of one of these things you would walk up to that computer. You would give it all the instructions. It needs to compute then it would take it and it would execute it. All right. Fast forward a little bit to desktop machines again programs recite it on the desktop machine the programmer application contains all the instructions that are needed to execute. So when people would write applications for it their code would be compiled down in the whole thing would be installed on the computer in one go and it will be installed on the same computer think of purely desktop only apps. Okay, something like Microsoft Word or a text editor that you install on your I mean this has historically influence how we write code when we need to write an application. We would start a new code project and we would add functionality into that project need more functionality add more code. And so the size of the code base for any given application keeps increasing over time. So what starts as a small code base might end up turning into a large complex code base over time and people realize this ",
                "confidence": 0.8558030125,
                "startTime": "2020-01-08T16:36:22Z",
                "endTime": "2020-01-08T16:38:22Z",
                "duration": 120,
                "recordingId": "422efda7-f3c4-4289-8cfe-43555d3b75d8",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "633ff311-2260-4360-b86d-74180458d399",
                "isEndOfSentence": false,
                "createdAt": "2020-01-08T16:38:23.330693876Z",
                "updatedAt": "2020-01-08T16:39:04.845283353Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "05a63dd9-cb73-4e21-b13d-e22c3e070549",
                "originalText": "Entry point application to talk to and from there on you can run a single application on one machine or 10 applications on 10 machines. Nobody cares. So here's an idea rather than have the whole applications mushed into one monolith and deployed into one machine. Why not split the application into smaller mini applications, then you can deploy these mini applications on different machines. You can have them talk to each other over the network and together work as the bigger application take for example, the e-commerce site you could create a shopping catalogue application that just has the shopping catalogue. Channel 2 and you'd applied on a separate server here order processing on another server user profile application is another server and let's say when the user wants to see the shopping catalogue the view of the question, which is another application makes a rest API call to the catalog applications API and say hey give me the list of products to show and the API Returns the list and then The View application returns an HTML with that last so these many applications talk to each other. Over the network by calling each other's rest apis to get whatever they want from each other. Okay. Well how would this help first the risk of deployment diseased making a change to the shopping catalogue application? Well, it's a separate application you can test and apply just that you don't have to test and apply the rest of the application secondly scaling no problem during the holidays you scale up only the shopping catalogue application. You'll be creating more serve instances only for the Minneapolis. Questions that you need so these mini applications our services are what are technically called microservices microservices are a way of breaking your application or service down into Standalone independent applications that can be run on different Hardware. ",
                "confidence": 0.880930012,
                "startTime": "2020-01-08T16:46:22Z",
                "endTime": "2020-01-08T16:48:22Z",
                "duration": 120,
                "recordingId": "85baaeeb-852b-4751-94ed-9e1948c479e8",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "633ff311-2260-4360-b86d-74180458d399",
                "isEndOfSentence": true,
                "createdAt": "2020-01-08T16:48:23.338762803Z",
                "updatedAt": "2020-01-08T16:49:04.94031863Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "0f8a6347-f638-4d14-8e08-eb1da26202b0",
                "originalText": "Best practices that were created to handle large projects developers were recommended to break things up into modules. So rather than put all your code into a single mess of a code base create smaller modules and compose your application from these modules small independent parts that were focused on just doing a small amount of functionality. These modules were supposed to be reusable. So a simple module could be added to another project to help another application see, isn't this awesome. Zoom and then once you've created your application this way, you're ready to build this whole application and deploy this on the machine that runs your application. Notice something here, when coding your application. You have all these modular constructs right nice fragmented organized pieces of functionality pieces of code that compose together to form your application. But still what you're doing is composing them to form one application and when you build it in deployed all those small pieces all get smushed together into one giant ball of distributable that is your final application build and that's what you'd apply to a machine again. Example of your text editor installer or Microsoft Word installer no matter how the developers of that application have modularize an organized their source code the final distributable. The final executable is just one thing but everything smushed together. This is important to remember okay. Remember this picture nice fancy modularized organized structure of the code, but one applications, so the final diploid entity smushed because nobody cares how the application looks on the user's machine, right? And everything needs to be deployed on to one machine. Anyway, this used to work for the most part for desktop applications people would happily develop and deploy applications this way and then and then there came along two things that would revolutionize and maybe even necessary ate some changes to the way we build applications. ",
                "confidence": 0.8567965379999999,
                "startTime": "2020-01-08T16:38:22Z",
                "endTime": "2020-01-08T16:40:22Z",
                "duration": 120,
                "recordingId": "c23853ce-ed35-4ad3-9770-a7a0ada6a5e4",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "633ff311-2260-4360-b86d-74180458d399",
                "isEndOfSentence": true,
                "createdAt": "2020-01-08T16:40:23.29994747Z",
                "updatedAt": "2020-01-08T16:41:25.072733737Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "1088db22-8fe2-41f6-892a-00a864350eef",
                "originalText": "Everything since the whole application is being deployed. Every time you will need to test the whole application every time you'd apply because anything in it could have a bug into Deuce. Yeah, you have automated tests and all that jazz, but it doesn't problem second problem with monolithic architectures scalability. We here is an example online e-commerce sites. They have very unprintable traffic spikes. Right? So let's say there is a sale on some product people rushed to the site like crazy and after this is over the draft. Is done similarly during holidays, there is a spike and there is a dip thankfully these days we have elastic servers. So when the traffic spikes up the number of application server instances are increased but then when the traffic goes back to normal the extra servers are retired, that's great. But imagine an entire e-commerce website deployed as a single monolith this monolith has shopping functionality user profile returns functionality a whole lot of other stuff. Let's say The traffic Spike on the shopping pages and the server scale up notice that all the other functionalities should scale up as well, even though nobody's using them they have to scale up because the whole thing is just one single application. So a big e-commerce site has to pay a lot more money to create these duplicate instances of the whole application when only a small portion of the app actually needs to be scaled up during the time of those spikes. There are a few other challenges, but I won't go into all of them now. Let's go back to To the story so that one guy who said they must be a better way. So the idea is like this back when we were deploying to desktop machines. We had to install the whole app on a single machine. We don't have a choice but fate now we have web applications the applications actually decide on a server the user who's sitting at home on their computer or phone. They don't care where your application is or have you'd applied or how you executive it. They just need ",
                "confidence": 0.875016705,
                "startTime": "2020-01-08T16:44:22Z",
                "endTime": "2020-01-08T16:46:22Z",
                "duration": 120,
                "recordingId": "1468620f-0bd0-4ca1-9929-12332f88e9d3",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "633ff311-2260-4360-b86d-74180458d399",
                "isEndOfSentence": false,
                "createdAt": "2020-01-08T16:46:23.232696003Z",
                "updatedAt": "2020-01-08T16:47:07.424642643Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "18346aa6-f07e-47a4-9b8b-bb417fc0a0be",
                "originalText": "Bus or even build them in different languages of platforms these microservices talk to each other through dressed. So it really doesn't matter what language you actually use you no longer have to use a Common Language or platform what else they can be scaled separately during the shopping traffic spikes. Just scale whatever micro services are most used. The other micro services are unaffected. There are many more advantages of course, but you also have to realize this opens up a whole lot of questions for all the advantages that that This is have they also have some problems as well earlier. You were dealing with one application. Now, we are dealing with tens or maybe hundreds of mini applications in the form of micro services. So you need to make sure you're not making things worse in general. Okay, so you're separating your application into microservices. What is this separation look like how do you ideally split your application up into microservices? So for example, for every feature you need to add to your application. If you need to make changes to 10 different microservices, it kind of defeats the purpose. So you need Separate these applications. Well, then there is a problem of how to make sure your microservices discover each other on a single machine on a monolith. It's fairly obvious have Services call each other but with microservices how do the services know which rest API endpoints to call in which environment do you hard-code these URLs or do you have a process around service Discovery? So there are a whole lot of questions here that needs to be answered and this in a nutshell is the whole thing about micro service architecture answering and solving for these problems. Is exactly what microservice architecture is all about and it's a signs of its own and it's even an art of its own before we wrap up this video though. I should clarify that there isn't a right or a wrong way to do these things. In fact, not all applications need to be architected as microservices. No matter how buzzworthy the term is right. Now. There are many applications that should be built with monolithic architectures. Please don't believe that microservices are somehow better than monolithic applications. They're just different and both approaches have their own. ",
                "confidence": 0.8844714850000001,
                "startTime": "2020-01-08T16:49:10Z",
                "endTime": "2020-01-08T16:51:10Z",
                "duration": 120,
                "recordingId": "d7aaaa93-4427-4d19-a29b-9deb5709333b",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "633ff311-2260-4360-b86d-74180458d399",
                "isEndOfSentence": true,
                "createdAt": "2020-01-08T16:51:11.924824884Z",
                "updatedAt": "2020-01-08T16:52:13.399840828Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "696b47e3-1a42-466c-99c3-d56d4d87e1c3",
                "originalText": "But for those two things first was the onset of the web applications people started to move away from applications that needed to be installed on the machine and towards web applications. That would be installed on a remote server machine somewhere on the internet and then you from your machine can use your web browser to access the result after execution on the remote machine thinks server-side applications. The server would prepare the HTML that you are web application needs to show. And notifications are actually deployed on your machine. But from your browser perhaps you just use your browser. The actual application would be deployed on server somewhere and your requests go to that thing and that processes it does whatever it needs to do and then returns back a response. Now, you might ask me how does this change things? Well for the most part nothing much changed initially. The only change was instead of developers installing their applications and all the Different users machines they would install them on just one server and all the users would just point to that seven access that server. This was awesome. Right? Everybody gets automatic updates very cool. But then the cord and the deployment model was still the same nice fancy modularized organized structure of the code, but all that composes to just one application and the final deploy identity smushed rather than deploying the smoosh on the user's machine. They were now deploying that smersh in one place. On the server then at some point of time due to various different reasons some people started wondering hmm. There must be a better way, but wait, let's pause the story for a bit and let's look at one other development that's been happening to Applications over the years turns out web apps have been growing very very incredibly very complicated over time. The first web applications from the past it very simple rudimentary things. I don't know like tell you that time or ",
                "confidence": 0.8542223375,
                "startTime": "2020-01-08T16:40:22Z",
                "endTime": "2020-01-08T16:42:22Z",
                "duration": 120,
                "recordingId": "6dc86ad1-2a74-43f0-a8f1-eb9182f70ea5",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "633ff311-2260-4360-b86d-74180458d399",
                "isEndOfSentence": false,
                "createdAt": "2020-01-08T16:42:23.270396033Z",
                "updatedAt": "2020-01-08T16:43:04.584210237Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "86e7c8ed-86e3-4f55-ba22-80c3d07f99ef",
                "originalText": "Several instances they all talk to each other over the rest apis and work together to provide the functionality of your application or product. So all that fancy organization that have been making to the code during development time. Well, you can have fancy organized separation of concerns for your applications in their diploid State as well. So you no longer have one application to build and apply you have several individual applications that I'll do a like a small thing each, but they work together work. With each other at runtime to form your actual complete application as far as your users are concerned now, what are the advantages of microservices we have covered this you have flexibility different teams can create and apply microservices independently they can. ",
                "confidence": 0.8409941999999999,
                "startTime": "2020-01-08T16:48:22Z",
                "endTime": "2020-01-08T16:49:09Z",
                "duration": 47,
                "recordingId": "ae942f4b-6b9e-4c32-8744-778e4af65a2d",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "633ff311-2260-4360-b86d-74180458d399",
                "isEndOfSentence": true,
                "createdAt": "2020-01-08T16:49:09.470395607Z",
                "updatedAt": "2020-01-08T16:49:31.172470723Z",
                "deletedAt": null,
                "deleted": false
            },
            {
                "id": "eeb68f96-a270-4fa9-b91a-3a3b577e4563",
                "originalText": "Nothing too fancy, but overtime web applications have started becoming better bigger quicker more complicated bigger scale bigger user base bigger everything and today we have web applications that can you know find something from the whole internet in a matter of milliseconds are fine. What cabs are available around you all over the world in milliseconds. These are incredible Feats if you think about it, and they need incredibly complicated code to be Developed and applied and this complexity becomes harder and harder to maintain. Hang on. We have nice modular architecture on the code side of things isn't that enough to handle the complexity during development time? Who cares about how the application is deployed. Right? Well with the type of applications we are talking about the complexity needs to be handled not just at the coding side of things. They also need to be handled at the runtime or execution side of things having a single thing that you'd apply. Didn't work anymore this way of having a single application is called the monolithic application or monolithic architecture mono means single lithic means Stone single Stone monolithic. This is the Smosh basically What are some of the disadvantages of this monolithic model first the bigger the deployment the more challenging the deployment Let me Give an example. Let's say you want to push a new feature to your big monolithic application. All right. So among all the code comments that you want to deploy is the single quote comment by this new guy. The company has just hired me not so sure about him. He probably doesn't know much and he still learning but his first code come it ever is still sitting there. And you're worried. What do you do? Well, you need to test the whole thing before you'd apply the whole application you never know which part of the application that come it might have broken. Well, I'm exaggerating here, of course, but the fact remains ",
                "confidence": 0.8319622320000001,
                "startTime": "2020-01-08T16:42:22Z",
                "endTime": "2020-01-08T16:44:22Z",
                "duration": 120,
                "recordingId": "60766f5c-f33f-4e6c-9eca-7183445b45e6",
                "spokenBy": "716067a60a1a4034abc49a12ecafb39b",
                "languageCode": "en-US",
                "transcriber": "google_speech_api",
                "status": "completed",
                "transcriptId": "633ff311-2260-4360-b86d-74180458d399",
                "isEndOfSentence": false,
                "createdAt": "2020-01-08T16:44:23.318234642Z",
                "updatedAt": "2020-01-08T16:45:25.099558037Z",
                "deletedAt": null,
                "deleted": false
            }
        ]
    }}